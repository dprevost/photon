/*
 * This file was generated by the program errorParser
 * using the input file ../../src/include/vdsf/vdsErrors.h.
 * (The code generator is copyrighted by Daniel Prevost 
 * <dprevost@users.sourceforge.net>)
 *
 * This file is free software; as a special exception the author gives
 * unlimited permission to copy and/or distribute it, with or without
 * modifications, as long as this notice is preserved.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
 * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 */

#include "Common/Common.h"
#include "VdsErrorHandler.h"

struct vdseErrErrMsgStruct
{
   int  errorNumber;
   int  messageLength;
   char *message;
};

typedef struct vdseErrErrMsgStruct vdseErrErrMsgStruct;

/* VDS_OK */
vdseErrErrMsgStruct vdseErrErrMsg0 =
   { 0, 11, "No error..." };

/* VDS_INTERNAL_ERROR */
vdseErrErrMsgStruct vdseErrErrMsg1 =
   { 666, 47, "Abnormal internal error - it should not happen!" };

/* VDS_ENGINE_BUSY */
vdseErrErrMsgStruct vdseErrErrMsg2 =
   { 1, 239, "Cannot get a lock on a system object, the engine is \"busy\". This might be the result of either a very busy system where unused cpu cycles are rare or a lock might be held by a crashed process (however the watchdog should catch this one)." };

/* VDS_NOT_ENOUGH_VDS_MEMORY */
vdseErrErrMsgStruct vdseErrErrMsg3 =
   { 2, 29, "Not enough memory in the VDS." };

/* VDS_NOT_ENOUGH_HEAP_MEMORY */
vdseErrErrMsgStruct vdseErrErrMsg4 =
   { 3, 40, "Not enough heap memory (non-VDS memory)." };

/* VDS_INVALID_OBJECT_NAME */
vdseErrErrMsgStruct vdseErrErrMsg5 =
   { 4, 150, "Permitted characters for names are alphanumerics [a-z,0-9], spaces (' '), dashes ('-') and underlines ('_'). The first character must be alphanumeric." };

/* VDS_NO_SUCH_OBJECT */
vdseErrErrMsgStruct vdseErrErrMsg6 =
   { 5, 53, "The object was not found (but its folder does exist)." };

/* VDS_NO_SUCH_FOLDER */
vdseErrErrMsgStruct vdseErrErrMsg7 =
   { 6, 20, "Invalid folder name." };

/* VDS_OBJECT_ALREADY_PRESENT */
vdseErrErrMsgStruct vdseErrErrMsg8 =
   { 7, 49, "Attempt to create an object which already exists." };

/* VDS_OBJECT_IN_USE */
vdseErrErrMsgStruct vdseErrErrMsg9 =
   { 8, 132, "Attempt to delete an object which is currently in use. The object might be used either by the current session or by another session." };

/* VDS_INVALID_LENGTH_FIELD */
vdseErrErrMsgStruct vdseErrErrMsg10 =
   { 9, 16, "To be written..." };

/* VDS_IS_EMPTY */
vdseErrErrMsgStruct vdseErrErrMsg11 =
   { 10, 37, "The object (data container) is empty." };

/* VDS_OBJECT_NOT_INITIALIZED */
vdseErrErrMsgStruct vdseErrErrMsg12 =
   { 11, 53, "Object must be open first before you can access them." };

/* VDS_CONFIG_ERROR */
vdseErrErrMsgStruct vdseErrErrMsg13 =
   { 12, 16, "To be written..." };

/* VDS_INVALID_WATCHDOG_ADDRESS */
vdseErrErrMsgStruct vdseErrErrMsg14 =
   { 13, 16, "To be written..." };

/* VDS_WRONG_OBJECT_TYPE */
vdseErrErrMsgStruct vdseErrErrMsg15 =
   { 14, 16, "To be written..." };

/* VDS_PROCESS_NOT_INITIALIZED */
vdseErrErrMsgStruct vdseErrErrMsg16 =
   { 15, 16, "To be written..." };

/* VDS_OBJECT_CANNOT_GET_LOCK */
vdseErrErrMsgStruct vdseErrErrMsg17 =
   { 16, 16, "To be written..." };

/* VDS_OBJECT_ALREADY_OPEN */
vdseErrErrMsgStruct vdseErrErrMsg18 =
   { 17, 16, "To be written..." };

/* VDS_PROCESS_ALREADY_INITIALIZED */
vdseErrErrMsgStruct vdseErrErrMsg19 =
   { 18, 92, "You must call vdsProcess::Terminate() before calling vdsProcess::Initialize() a second time." };

/* VDS_INCOMPATIBLE_VERSIONS */
vdseErrErrMsgStruct vdseErrErrMsg20 =
   { 19, 35, "API - memory-file version mismatch." };

/* VDS_NO_ROLLBACK */
vdseErrErrMsgStruct vdseErrErrMsg21 =
   { 20, 64, "Rollback operations are not permitted for implicit transactions." };

/* VDS_LOGFILE_ERROR */
vdseErrErrMsgStruct vdseErrErrMsg22 =
   { 21, 51, "Error opening the log file (used for transactions)." };

/* VDS_REACHED_THE_END */
vdseErrErrMsgStruct vdseErrErrMsg23 =
   { 22, 61, "The search reached the end without finding a new item/record." };

/* VDS_INVALID_ITERATOR */
vdseErrErrMsgStruct vdseErrErrMsg24 =
   { 23, 58, "An invalid value was used for a vdsIteratorType parameter." };

/* VDS_NOT_ENOUGH_RESOURCES */
vdseErrErrMsgStruct vdseErrErrMsg25 =
   { 24, 239, "There are not enough resources to correctly process the call. This might be due to a lack of POSIX semaphores on systems where locks are implemented that way or a failure in initializing a pthread_mutex (or on Windows, a critical section)." };

/* VDS_NO_CONFIG_FILE */
vdseErrErrMsgStruct vdseErrErrMsg26 =
   { 25, 16, "To be written..." };

/* VDS_SOCKET_ERROR */
vdseErrErrMsgStruct vdseErrErrMsg27 =
   { 26, 16, "To be written..." };

/* VDS_CONNECT_ERROR */
vdseErrErrMsgStruct vdseErrErrMsg28 =
   { 27, 16, "To be written..." };

/* VDS_SEND_ERROR */
vdseErrErrMsgStruct vdseErrErrMsg29 =
   { 28, 16, "To be written..." };

/* VDS_RECEIVE_ERROR */
vdseErrErrMsgStruct vdseErrErrMsg30 =
   { 29, 16, "To be written..." };

/* VDS_BACKSTORE_FILE_MISSING */
vdseErrErrMsgStruct vdseErrErrMsg31 =
   { 30, 16, "To be written..." };

/* VDS_ERROR_OPENING_VDS */
vdseErrErrMsgStruct vdseErrErrMsg32 =
   { 31, 16, "To be written..." };

/* VDS_FOLDER_IS_NOT_EMPTY */
vdseErrErrMsgStruct vdseErrErrMsg33 =
   { 32, 16, "To be written..." };

/* VDS_WRONG_TYPE_HANDLE */
vdseErrErrMsgStruct vdseErrErrMsg34 =
   { 33, 41, "The provided handle is of the wrong type." };

/* VDS_NULL_HANDLE */
vdseErrErrMsgStruct vdseErrErrMsg35 =
   { 34, 35, "The provided handle is NULL (zero)." };

/* VDS_OBJECT_NAME_TOO_LONG */
vdseErrErrMsgStruct vdseErrErrMsg36 =
   { 35, 164, "The name of the object is too long. The maximum length of a name cannot be more than VDS_MAX_NAME_LENGTH (or VDS_MAX_FULL_NAME_LENGTH for the fully qualified name)." };

/* VDS_SESSION_CANNOT_GET_LOCK */
vdseErrErrMsgStruct vdseErrErrMsg37 =
   { 36, 84, "Cannot get a lock on the session (a pthread_mutex or a critical section on Windows)." };

/* VDS_SESSION_IS_TERMINATED */
vdseErrErrMsgStruct vdseErrErrMsg38 =
   { 37, 97, "An attempt was made to use a session object (a session handle) after this session was terminated." };

/* VDS_ITEM_ALREADY_PRESENT */
vdseErrErrMsgStruct vdseErrErrMsg39 =
   { 38, 36, "An item with the same key was found." };

/* VDS_NO_SUCH_ITEM */
vdseErrErrMsgStruct vdseErrErrMsg40 =
   { 39, 38, "The item was not found in the hash map" };

/* VDS_OBJECT_IS_DELETED */
vdseErrErrMsgStruct vdseErrErrMsg41 =
   { 40, 109, "The object is scheduled to be deleted soon. Operations on this data container are not permitted at this time." };

/* VDS_NULL_POINTER */
vdseErrErrMsgStruct vdseErrErrMsg42 =
   { 41, 67, "One of the arguments of an API function is an invalid NULL pointer." };

vdseErrErrMsgStruct* vdseErrErrMsg[VDSEERR_MAX_ENTRIES] = 
{
   &vdseErrErrMsg0,
   &vdseErrErrMsg1,
   &vdseErrErrMsg2,
   &vdseErrErrMsg3,
   &vdseErrErrMsg4,
   &vdseErrErrMsg5,
   &vdseErrErrMsg6,
   &vdseErrErrMsg7,
   &vdseErrErrMsg8,
   &vdseErrErrMsg9,
   &vdseErrErrMsg10,
   &vdseErrErrMsg11,
   &vdseErrErrMsg12,
   &vdseErrErrMsg13,
   &vdseErrErrMsg14,
   &vdseErrErrMsg15,
   &vdseErrErrMsg16,
   &vdseErrErrMsg17,
   &vdseErrErrMsg18,
   &vdseErrErrMsg19,
   &vdseErrErrMsg20,
   &vdseErrErrMsg21,
   &vdseErrErrMsg22,
   &vdseErrErrMsg23,
   &vdseErrErrMsg24,
   &vdseErrErrMsg25,
   &vdseErrErrMsg26,
   &vdseErrErrMsg27,
   &vdseErrErrMsg28,
   &vdseErrErrMsg29,
   &vdseErrErrMsg30,
   &vdseErrErrMsg31,
   &vdseErrErrMsg32,
   &vdseErrErrMsg33,
   &vdseErrErrMsg34,
   &vdseErrErrMsg35,
   &vdseErrErrMsg36,
   &vdseErrErrMsg37,
   &vdseErrErrMsg38,
   &vdseErrErrMsg39,
   &vdseErrErrMsg40,
   &vdseErrErrMsg41,
   &vdseErrErrMsg42

};

int vdseErrGetErrMessage( int errnum, char *msg, unsigned int msgLength )
{
   int i;

   if ( msgLength > 0 ) msg[0] = '\0';
   for ( i = 0; i < VDSEERR_MAX_ENTRIES; ++i )
   {
      if ( errnum == vdseErrErrMsg[i]->errorNumber )
      {
         if ( msgLength > 0 && vdseErrErrMsg[i]->messageLength > 0 )
         {
            strncpy( msg, vdseErrErrMsg[i]->message, msgLength-1 );
            msg[msgLength-1] = '\0';
         }
         return 0;
      }
   }

   return -1;
}
