/*
 * This file was generated by the program errorParser
 * using the input file ../../src/include/vdsf/vdsErrors.h.
 * (The code generator is copyrighted by Daniel Prevost 
 * <dprevost@users.sourceforge.net>)
 *
 * This file is free software; as a special exception the author gives
 * unlimited permission to copy and/or distribute it, with or without
 * modifications, as long as this notice is preserved.
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY, to the extent permitted by law; without even the
 * implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 */

#include "Common/Common.h"
#include "VdsErrorHandler.h"

struct vdseErrErrMsgStruct
{
   int  errorNumber;
   int  messageLength;
   char *message;
};

typedef struct vdseErrErrMsgStruct vdseErrErrMsgStruct;

/* VDS_OK */
vdseErrErrMsgStruct vdseErrErrMsg0 =
   { 0, 11, "No error..." };

/* VDS_INTERNAL_ERROR */
vdseErrErrMsgStruct vdseErrErrMsg1 =
   { 666, 47, "Abnormal internal error - it should not happen!" };

/* VDS_ENGINE_BUSY */
vdseErrErrMsgStruct vdseErrErrMsg2 =
   { 1, 194, "Cannot get a lock on a system object, the engine is \"busy\". This might be the result of either a very busy system where unused cpu cycles are rare or a lock might be held by a crashed process." };

/* VDS_NOT_ENOUGH_VDS_MEMORY */
vdseErrErrMsgStruct vdseErrErrMsg3 =
   { 2, 29, "Not enough memory in the VDS." };

/* VDS_NOT_ENOUGH_HEAP_MEMORY */
vdseErrErrMsgStruct vdseErrErrMsg4 =
   { 3, 40, "Not enough heap memory (non-VDS memory)." };

/* VDS_NOT_ENOUGH_RESOURCES */
vdseErrErrMsgStruct vdseErrErrMsg5 =
   { 4, 239, "There are not enough resources to correctly process the call. This might be due to a lack of POSIX semaphores on systems where locks are implemented that way or a failure in initializing a pthread_mutex (or on Windows, a critical section)." };

/* VDS_WRONG_TYPE_HANDLE */
vdseErrErrMsgStruct vdseErrErrMsg6 =
   { 5, 41, "The provided handle is of the wrong type." };

/* VDS_NULL_HANDLE */
vdseErrErrMsgStruct vdseErrErrMsg7 =
   { 6, 35, "The provided handle is NULL (zero)." };

/* VDS_NULL_POINTER */
vdseErrErrMsgStruct vdseErrErrMsg8 =
   { 7, 67, "One of the arguments of an API function is an invalid NULL pointer." };

/* VDS_INVALID_LENGTH */
vdseErrErrMsgStruct vdseErrErrMsg9 =
   { 8, 94, "An invalid length was provided (it will usually indicate that the length value is set to zero." };

/* VDS_PROCESS_ALREADY_INITIALIZED */
vdseErrErrMsgStruct vdseErrErrMsg10 =
   { 21, 76, "The process was already initialized. Was vdsInit() called for a second time?" };

/* VDS_PROCESS_NOT_INITIALIZED */
vdseErrErrMsgStruct vdseErrErrMsg11 =
   { 22, 63, "The process was not properly initialized. Was vdsInit() called?" };

/* VDS_INVALID_WATCHDOG_ADDRESS */
vdseErrErrMsgStruct vdseErrErrMsg12 =
   { 23, 66, "The watchdog address is invalid (empty string, NULL pointer, etc.)" };

/* VDS_INCOMPATIBLE_VERSIONS */
vdseErrErrMsgStruct vdseErrErrMsg13 =
   { 24, 35, "API - memory-file version mismatch." };

/* VDS_SOCKET_ERROR */
vdseErrErrMsgStruct vdseErrErrMsg14 =
   { 25, 21, "Generic socket error." };

/* VDS_CONNECT_ERROR */
vdseErrErrMsgStruct vdseErrErrMsg15 =
   { 26, 52, "Socket error when trying to connect to the watchdog." };

/* VDS_SEND_ERROR */
vdseErrErrMsgStruct vdseErrErrMsg16 =
   { 27, 59, "Socket error when trying to send a request to the watchdog." };

/* VDS_RECEIVE_ERROR */
vdseErrErrMsgStruct vdseErrErrMsg17 =
   { 28, 62, "Socket error when trying to receive a reply from the watchdog." };

/* VDS_BACKSTORE_FILE_MISSING */
vdseErrErrMsgStruct vdseErrErrMsg18 =
   { 29, 86, "The vds backstore file is missing (the name of this file is provided by the watchdog)." };

/* VDS_ERROR_OPENING_VDS */
vdseErrErrMsgStruct vdseErrErrMsg19 =
   { 30, 50, "Generic i/o error when attempting to open the vds." };

/* VDS_LOGFILE_ERROR */
vdseErrErrMsgStruct vdseErrErrMsg20 =
   { 41, 85, "Error accessing the directory for the log files or error opening the log file itself." };

/* VDS_SESSION_CANNOT_GET_LOCK */
vdseErrErrMsgStruct vdseErrErrMsg21 =
   { 42, 84, "Cannot get a lock on the session (a pthread_mutex or a critical section on Windows)." };

/* VDS_SESSION_IS_TERMINATED */
vdseErrErrMsgStruct vdseErrErrMsg22 =
   { 43, 97, "An attempt was made to use a session object (a session handle) after this session was terminated." };

/* VDS_INVALID_OBJECT_NAME */
vdseErrErrMsgStruct vdseErrErrMsg23 =
   { 51, 140, "Permitted characters for names are alphanumerics, spaces (' '), dashes ('-') and underlines ('_'). The first character must be alphanumeric." };

/* VDS_NO_SUCH_OBJECT */
vdseErrErrMsgStruct vdseErrErrMsg24 =
   { 52, 53, "The object was not found (but its folder does exist)." };

/* VDS_NO_SUCH_FOLDER */
vdseErrErrMsgStruct vdseErrErrMsg25 =
   { 53, 53, "One of the parent folder of an object does not exist." };

/* VDS_OBJECT_ALREADY_PRESENT */
vdseErrErrMsgStruct vdseErrErrMsg26 =
   { 54, 49, "Attempt to create an object which already exists." };

/* VDS_IS_EMPTY */
vdseErrErrMsgStruct vdseErrErrMsg27 =
   { 55, 37, "The object (data container) is empty." };

/* VDS_WRONG_OBJECT_TYPE */
vdseErrErrMsgStruct vdseErrErrMsg28 =
   { 56, 54, "Attempt to create an object of an unknown object type." };

/* VDS_OBJECT_CANNOT_GET_LOCK */
vdseErrErrMsgStruct vdseErrErrMsg29 =
   { 57, 163, "Cannot get lock on the object. This might be the result of either a very busy system where unused cpu cycles are rare or a lock might be held by a crashed process." };

/* VDS_REACHED_THE_END */
vdseErrErrMsgStruct vdseErrErrMsg30 =
   { 58, 71, "The search/iteration reached the end without finding a new item/record." };

/* VDS_INVALID_ITERATOR */
vdseErrErrMsgStruct vdseErrErrMsg31 =
   { 59, 58, "An invalid value was used for a vdsIteratorType parameter." };

/* VDS_OBJECT_NAME_TOO_LONG */
vdseErrErrMsgStruct vdseErrErrMsg32 =
   { 60, 164, "The name of the object is too long. The maximum length of a name cannot be more than VDS_MAX_NAME_LENGTH (or VDS_MAX_FULL_NAME_LENGTH for the fully qualified name)." };

/* VDS_FOLDER_IS_NOT_EMPTY */
vdseErrErrMsgStruct vdseErrErrMsg33 =
   { 61, 247, "You cannot delete a folder if there are still undeleted objects in it. Technical: a folder does not need to be empty to be deleted but all objects in it must be \"marked as deleted\" by the current session. This enables writing recursive deletions" };

/* VDS_ITEM_ALREADY_PRESENT */
vdseErrErrMsgStruct vdseErrErrMsg34 =
   { 62, 36, "An item with the same key was found." };

/* VDS_NO_SUCH_ITEM */
vdseErrErrMsgStruct vdseErrErrMsg35 =
   { 63, 38, "The item was not found in the hash map" };

/* VDS_OBJECT_IS_DELETED */
vdseErrErrMsgStruct vdseErrErrMsg36 =
   { 64, 109, "The object is scheduled to be deleted soon. Operations on this data container are not permitted at this time." };

/* VDS_OBJECT_NOT_INITIALIZED */
vdseErrErrMsgStruct vdseErrErrMsg37 =
   { 65, 53, "Object must be open first before you can access them." };

/* VDS_ITEM_IS_IN_USE */
vdseErrErrMsgStruct vdseErrErrMsg38 =
   { 66, 148, "The data item is scheduled to be deleted soon or was just created and is not committed. Operations on this data item are not permitted at this time." };

/* VDS_ITEM_IS_DELETED */
vdseErrErrMsgStruct vdseErrErrMsg39 =
   { 67, 112, "The data item is scheduled to be deleted soon. Operations on this data container are not permitted at this time." };

/* VDS_I18N_CONVERSION_ERROR */
vdseErrErrMsgStruct vdseErrErrMsg40 =
   { 68, 116, "i18n string conversion error. In other words, the name of the object cannot be converted to/frm your current locale." };

/* VDS_OBJECT_IS_IN_USE */
vdseErrErrMsgStruct vdseErrErrMsg41 =
   { 69, 142, "The object is scheduled to be deleted soon or was just created and is not committed. Operations on this object are not permitted at this time." };

vdseErrErrMsgStruct* vdseErrErrMsg[VDSEERR_MAX_ENTRIES] = 
{
   &vdseErrErrMsg0,
   &vdseErrErrMsg1,
   &vdseErrErrMsg2,
   &vdseErrErrMsg3,
   &vdseErrErrMsg4,
   &vdseErrErrMsg5,
   &vdseErrErrMsg6,
   &vdseErrErrMsg7,
   &vdseErrErrMsg8,
   &vdseErrErrMsg9,
   &vdseErrErrMsg10,
   &vdseErrErrMsg11,
   &vdseErrErrMsg12,
   &vdseErrErrMsg13,
   &vdseErrErrMsg14,
   &vdseErrErrMsg15,
   &vdseErrErrMsg16,
   &vdseErrErrMsg17,
   &vdseErrErrMsg18,
   &vdseErrErrMsg19,
   &vdseErrErrMsg20,
   &vdseErrErrMsg21,
   &vdseErrErrMsg22,
   &vdseErrErrMsg23,
   &vdseErrErrMsg24,
   &vdseErrErrMsg25,
   &vdseErrErrMsg26,
   &vdseErrErrMsg27,
   &vdseErrErrMsg28,
   &vdseErrErrMsg29,
   &vdseErrErrMsg30,
   &vdseErrErrMsg31,
   &vdseErrErrMsg32,
   &vdseErrErrMsg33,
   &vdseErrErrMsg34,
   &vdseErrErrMsg35,
   &vdseErrErrMsg36,
   &vdseErrErrMsg37,
   &vdseErrErrMsg38,
   &vdseErrErrMsg39,
   &vdseErrErrMsg40,
   &vdseErrErrMsg41

};

int vdseErrGetErrMessage( int errnum, char *msg, unsigned int msgLength )
{
   int i;

   if ( msgLength > 0 ) msg[0] = '\0';
   for ( i = 0; i < VDSEERR_MAX_ENTRIES; ++i )
   {
      if ( errnum == vdseErrErrMsg[i]->errorNumber )
      {
         if ( msgLength > 0 && vdseErrErrMsg[i]->messageLength > 0 )
         {
            strncpy( msg, vdseErrErrMsg[i]->message, msgLength-1 );
            msg[msgLength-1] = '\0';
         }
         return 0;
      }
   }

   return -1;
}
