.TH "API functions for Photon sessions." 3 "27 Mar 2009" "Version 0.5.0" "Photon Software" \" -*- nroff -*-
.ad l
.nh
.SH NAME
API functions for Photon sessions. \- 
.SH "Detailed Description"
.PP 
Sessions exist mainly to support multi-threaded (MT) programs. 
.PP
Best practices: 
.PD 0

.IP "\(bu" 2
Each thread of an MT program should have its own session, making it independent of the other threads. 
.PP

.IP "\(bu" 2
If you need to open the same Photon object in multiple threads, simply open it multiple times, for each thread. The overhead of having multiple handles to the same shared-memory data container is minimal and using this technique instead of using multi-thread locks will increases the overall performance of the software. 
.PP

.IP "\(bu" 2
Signal handlers (and similar calls): you should not call \fBpsoExit\fP or \fBpsoExitSession\fP (or similar) from a signal handler. Instead, some global flags should be set that will allow each session to terminate in an orderly fashion.  
.PP
.PP
If you cannot follow these guidelines for whatever reasons, you should set the parameter \fIprotectionNeeded\fP of \fBpsoInit\fP to 1. This will introduce additional multi-threaded protection (locking) for your applications.
.PP
Additional note: API objects (or C handles) are just proxies for the real objects sitting in shared memory. Proper synchronization is already done in shared memory and it is best to avoid the additional synchronization of these proxy objects. 
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoCommit\fP (\fBPSO_HANDLE\fP sessionHandle)"
.br
.RI "\fICommit all insertions and deletions (of the current session) executed since the previous call to psoCommit or psoRollback. \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoCreateObject\fP (\fBPSO_HANDLE\fP sessionHandle, const char *objectName, \fBpsoUint32\fP nameLengthInBytes, \fBpsoObjectDefinition\fP *definition, const unsigned char *keyDef, \fBpsoUint32\fP keyDefLength, const unsigned char *dataDef, \fBpsoUint32\fP dataDefLength)"
.br
.RI "\fICreate a new object in shared memory. \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoDestroyObject\fP (\fBPSO_HANDLE\fP sessionHandle, const char *objectName, \fBpsoUint32\fP nameLengthInBytes)"
.br
.RI "\fIDestroy an existing object in shared memory. \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoErrorMsg\fP (\fBPSO_HANDLE\fP sessionHandle, char *message, \fBpsoUint32\fP msgLengthInBytes)"
.br
.RI "\fIReturn the error message associated with the last error(s). \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoExitSession\fP (\fBPSO_HANDLE\fP sessionHandle)"
.br
.RI "\fITerminate the current session. \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoGetDefinition\fP (\fBPSO_HANDLE\fP sessionHandle, const char *objectName, \fBpsoUint32\fP nameLengthInBytes, \fBpsoObjectDefinition\fP *definition, unsigned char *key, \fBpsoUint32\fP keyLength, unsigned char *fields, \fBpsoUint32\fP fieldsLength)"
.br
.RI "\fIRetrieve the data definition of the named object. \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoGetDefLength\fP (\fBPSO_HANDLE\fP sessionHandle, const char *objectName, \fBpsoUint32\fP nameLengthInBytes, \fBpsoUint32\fP *keyLength, \fBpsoUint32\fP *fieldsLength)"
.br
.RI "\fIRetrieve the lengths of the variable elements of the definition of the named object. \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoGetInfo\fP (\fBPSO_HANDLE\fP sessionHandle, \fBpsoInfo\fP *pInfo)"
.br
.RI "\fIReturn information on the current status of the shared memory. \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoGetStatus\fP (\fBPSO_HANDLE\fP sessionHandle, const char *objectName, \fBpsoUint32\fP nameLengthInBytes, \fBpsoObjStatus\fP *pStatus)"
.br
.RI "\fIReturn the status of the named object. \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoInitSession\fP (\fBPSO_HANDLE\fP *sessionHandle)"
.br
.RI "\fIThis function initializes a session. \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoLastError\fP (\fBPSO_HANDLE\fP sessionHandle)"
.br
.RI "\fIReturn the last error seen in previous calls (of the current session). \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoRollback\fP (\fBPSO_HANDLE\fP sessionHandle)"
.br
.RI "\fIRollback all insertions and deletions (of the current session) executed since the previous call to psoCommit or psoRollback. \fP"
.in -1c
.SH "Function Documentation"
.PP 
.SS "PHOTON_EXPORT int psoCommit (\fBPSO_HANDLE\fP sessionHandle)"
.PP
Commit all insertions and deletions (of the current session) executed since the previous call to psoCommit or psoRollback. 
.PP
Insertions and deletions subjected to this call include both data items inserted, replaced and deleted from data containers (maps, etc.) and the objects themselves created, for example, with \fBpsoCreateObject\fP and/or destroyed with \fBpsoDestroyObject\fP.
.PP
Note: the internal calls executed by the engine to satisfy this request cannot fail. As such, you cannot find yourself with an ugly situation where some operations were committed and others not. If an error is returned by this function, nothing was committed.
.PP
\fBParameters:\fP
.RS 4
\fIsessionHandle\fP Handle to the current session.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoCreateObject (\fBPSO_HANDLE\fP sessionHandle, const char * objectName, \fBpsoUint32\fP nameLengthInBytes, \fBpsoObjectDefinition\fP * definition, const unsigned char * keyDef, \fBpsoUint32\fP keyDefLength, const unsigned char * dataDef, \fBpsoUint32\fP dataDefLength)"
.PP
Create a new object in shared memory. 
.PP
The creation of the object only becomes permanent after a call to \fBpsoCommit\fP.
.PP
This function does not provide a handle to the newly created object. Use \fBpsoQueueOpen\fP and similar functions to get the handle.
.PP
\fBParameters:\fP
.RS 4
\fIsessionHandle\fP Handle to the current session. 
.br
\fIobjectName\fP The fully qualified name of the object. 
.br
\fInameLengthInBytes\fP The length of \fIobjectName\fP (in bytes) not counting the null terminator (null-terminators are not used by the Photon engine). 
.br
\fIdefinition\fP The basic information needed to create the object: the type of object to create (folder, queue, etc.), the type of key definition, etc. 
.br
\fIkeyDef\fP An opaque definition of the key. You can set this field to NULL if the object has no key. See \fBpsoDefinitionType\fP for a more in-depth explanation. 
.br
\fIkeyDefLength\fP The length in bytes of the buffer \fIkeyDef\fP. It should be set to zero if \fIkeyDef\fP is NULL. 
.br
\fIdataDef\fP An opaque definition of the data fields of the object. It can be set to NULL when creating a Folder. See \fBpsoDefinitionType\fP for a more in-depth explanation. 
.br
\fIdataDefLength\fP The length in bytes of the buffer \fIdataDef\fP. It should be set to zero if \fIdataDef\fP is NULL.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoDestroyObject (\fBPSO_HANDLE\fP sessionHandle, const char * objectName, \fBpsoUint32\fP nameLengthInBytes)"
.PP
Destroy an existing object in shared memory. 
.PP
The destruction of the object only becomes permanent after a call to \fBpsoCommit\fP.
.PP
\fBParameters:\fP
.RS 4
\fIsessionHandle\fP Handle to the current session. 
.br
\fIobjectName\fP The fully qualified name of the object. 
.br
\fInameLengthInBytes\fP The length of \fIobjectName\fP (in bytes) not counting the null terminator (null-terminators are not used by the Photon engine).
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoErrorMsg (\fBPSO_HANDLE\fP sessionHandle, char * message, \fBpsoUint32\fP msgLengthInBytes)"
.PP
Return the error message associated with the last error(s). 
.PP
If the length of the error message is greater than the length of the provided buffer, the error message will be truncated to fit in the provided buffer.
.PP
Caveat, some basic errors cannot be captured, if the provided handles (session handles or object handles) are incorrect (NULL, for example). Without a proper handle, the code cannot know where to store the error...
.PP
\fBParameters:\fP
.RS 4
\fIsessionHandle\fP Handle to the current session. 
.br
\fImessage\fP Buffer for the error message. Memory allocation for this buffer is the responsability of the caller. 
.br
\fImsgLengthInBytes\fP The length of \fImessage\fP (in bytes). Must be at least 32 bytes.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoExitSession (\fBPSO_HANDLE\fP sessionHandle)"
.PP
Terminate the current session. 
.PP
An implicit call to \fBpsoRollback\fP is executed by this function.
.PP
Once this function is executed, attempts to use the session handle might lead to memory violation (and, possibly, crashes).
.PP
\fBParameters:\fP
.RS 4
\fIsessionHandle\fP Handle to the current session.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoGetDefinition (\fBPSO_HANDLE\fP sessionHandle, const char * objectName, \fBpsoUint32\fP nameLengthInBytes, \fBpsoObjectDefinition\fP * definition, unsigned char * key, \fBpsoUint32\fP keyLength, unsigned char * fields, \fBpsoUint32\fP fieldsLength)"
.PP
Retrieve the data definition of the named object. 
.PP
You can call the function \fBpsoGetDefLength\fP to retrieve the lengths of the key and the field definitions. This allows you to allocate the proper size for \fIkey\fP and \fIfields\fP.
.PP
\fBParameters:\fP
.RS 4
\fIsessionHandle\fP Handle to the current session. 
.br
\fIobjectName\fP The fully qualified name of the object. 
.br
\fInameLengthInBytes\fP The length of \fIobjectName\fP (in bytes) not counting the null terminator (null-terminators are not used by the Photon engine). 
.br
\fIdefinition\fP The definition of the object. 
.br
\fIkey\fP An opaque definition of the key. You can set this field to NULL if the object has no key or if you do not want to retrieve the key definition. 
.br
\fIkeyLength\fP The length in bytes of the buffer \fIkey\fP. It should be set to zero if \fIkey\fP is NULL. 
.br
\fIfields\fP An opaque definition of the data fields of the object. It can be set to NULL if you do not want to retrieve the definition. 
.br
\fIfieldsLength\fP The length in bytes of the buffer \fIfields\fP. It should be set to zero if \fIfields\fP is NULL.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoGetDefLength (\fBPSO_HANDLE\fP sessionHandle, const char * objectName, \fBpsoUint32\fP nameLengthInBytes, \fBpsoUint32\fP * keyLength, \fBpsoUint32\fP * fieldsLength)"
.PP
Retrieve the lengths of the variable elements of the definition of the named object. 
.PP
This function is a helper function for \fBpsoGetDefinition\fP. It allows you to allocate the proper size for \fIkey\fP and \fIfields\fP.
.PP
\fBParameters:\fP
.RS 4
\fIsessionHandle\fP Handle to the current session. 
.br
\fIobjectName\fP The fully qualified name of the object. 
.br
\fInameLengthInBytes\fP The length of \fIobjectName\fP (in bytes) not counting the null terminator (null-terminators are not used by the Photon engine). 
.br
\fIkeyLength\fP The length in bytes of the key buffer. keyLength cannot be NULL even if the objects has no key. 
.br
\fIfieldsLength\fP The length in bytes of the fields buffer. This pointer cannot be NULL.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoGetInfo (\fBPSO_HANDLE\fP sessionHandle, \fBpsoInfo\fP * pInfo)"
.PP
Return information on the current status of the shared memory. 
.PP
The fetched information is mainly about the current status of the memory allocator and information needed to provide better support (compiler, etc.).
.PP
\fBParameters:\fP
.RS 4
\fIsessionHandle\fP Handle to the current session. 
.br
\fIpInfo\fP A pointer to the \fBpsoInfo\fP structure.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoGetStatus (\fBPSO_HANDLE\fP sessionHandle, const char * objectName, \fBpsoUint32\fP nameLengthInBytes, \fBpsoObjStatus\fP * pStatus)"
.PP
Return the status of the named object. 
.PP
\fBParameters:\fP
.RS 4
\fIsessionHandle\fP Handle to the current session. 
.br
\fIobjectName\fP The fully qualified name of the object. 
.br
\fInameLengthInBytes\fP The length of \fIobjectName\fP (in bytes) not counting the null terminator (null-terminators are not used by the Photon engine). 
.br
\fIpStatus\fP A pointer to the \fBpsoObjStatus\fP structure.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoInitSession (\fBPSO_HANDLE\fP * sessionHandle)"
.PP
This function initializes a session. 
.PP
It takes one output argument, the session handle.
.PP
Upon successful completion, the session handle is set and the function returns zero. Otherwise the error code is returned and the handle is set to NULL.
.PP
This function will also initiate a new transaction.
.PP
Upon normal termination, the current transaction is rolled back. You MUST explicitly call psonCommit to save your changes.
.PP
\fBParameters:\fP
.RS 4
\fIsessionHandle\fP The handle to the newly created session.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoLastError (\fBPSO_HANDLE\fP sessionHandle)"
.PP
Return the last error seen in previous calls (of the current session). 
.PP
Caveat, some basic errors cannot be captured, if the provided handles (session handles or object handles) are incorrect (NULL, for example). Without a proper handle, the code cannot know where to store the error...
.PP
\fBParameters:\fP
.RS 4
\fIsessionHandle\fP Handle to the current session.
.RE
.PP
\fBReturns:\fP
.RS 4
The last error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoRollback (\fBPSO_HANDLE\fP sessionHandle)"
.PP
Rollback all insertions and deletions (of the current session) executed since the previous call to psoCommit or psoRollback. 
.PP
Insertions and deletions subjected to this call include both data items inserted and deleted from data containers (maps, etc.) and objects themselves created with psoCreateObj and/or destroyed with psoDestroyObj.
.PP
Note: the internal calls executed by the engine to satisfy this request cannot fail. As such, you cannot find yourself with an ugly situation where some operations were rollbacked and others not. If an error is returned by this function, nothing was rollbacked.
.PP
\fBParameters:\fP
.RS 4
\fIsessionHandle\fP Handle to the current session.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

