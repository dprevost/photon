.TH "vds_c.h" 3 "4 Nov 2006" "Version 0.1" "vdsf C API" \" -*- nroff -*-
.ad l
.nh
.SH NAME
vds_c.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'vdsf/vdsErrors.h'\fP
.br
\fC#include 'vdsf/vdsCommon.h'\fP
.br

.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void * \fBVDS_HANDLE\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBvdsInit\fP (const char *wdAddress, int protectionNeeded, \fBVDS_HANDLE\fP *processHandle)"
.br
.RI "\fIThis function initializes access to a VDS. \fP"
.ti -1c
.RI "void \fBvdsExit\fP (\fBVDS_HANDLE\fP processHandle)"
.br
.RI "\fIThis function terminates all access to the VDS. \fP"
.ti -1c
.RI "int \fBvdsInitSession\fP (int explicitTransaction, \fBVDS_HANDLE\fP *sessionHandle)"
.br
.RI "\fIThis function initializes a session. \fP"
.ti -1c
.RI "void \fBvdsExitSession\fP (\fBVDS_HANDLE\fP handle)"
.br
.ti -1c
.RI "int \fBvdsCreateObject\fP (\fBVDS_HANDLE\fP handle, const char *objectName, vdsObjectType objectType)"
.br
.ti -1c
.RI "int \fBvdsDestroyObject\fP (\fBVDS_HANDLE\fP handle, const char *objectName)"
.br
.ti -1c
.RI "int \fBvdsCommit\fP (\fBVDS_HANDLE\fP handle)"
.br
.ti -1c
.RI "int \fBvdsRollback\fP (\fBVDS_HANDLE\fP handle)"
.br
.ti -1c
.RI "int \fBvdsFolderOpen\fP (\fBVDS_HANDLE\fP sessionHandle, const char *folderName, \fBVDS_HANDLE\fP *objectHandle)"
.br
.ti -1c
.RI "int \fBvdsFolderClose\fP (\fBVDS_HANDLE\fP objectHandle)"
.br
.ti -1c
.RI "int \fBvdsQueueOpen\fP (\fBVDS_HANDLE\fP sessionHandle, const char *queueName, \fBVDS_HANDLE\fP *objectHandle)"
.br
.ti -1c
.RI "int \fBvdsQueueClose\fP (\fBVDS_HANDLE\fP objectHandle)"
.br
.ti -1c
.RI "int \fBvdsQueueInsertItem\fP (\fBVDS_HANDLE\fP objectHandle, const void *pItem, size_t length)"
.br
.ti -1c
.RI "int \fBvdsQueueRemoveItem\fP (\fBVDS_HANDLE\fP objectHandle, void *pItem, size_t length)"
.br
.ti -1c
.RI "int \fBvdsQueueGetItem\fP (\fBVDS_HANDLE\fP objectHandle, vdsIteratorType flag, void *pItem, size_t length)"
.br
.ti -1c
.RI "int \fBvdsQueueStatus\fP (\fBVDS_HANDLE\fP objectHandle, size_t *pNumValidItems, size_t *pNumTotalItems)"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef void* \fBVDS_HANDLE\fP"
.PP
Definition at line 28 of file vds_c.h.
.SH "Function Documentation"
.PP 
.SS "int vdsCommit (\fBVDS_HANDLE\fP handle)"
.PP
.SS "int vdsCreateObject (\fBVDS_HANDLE\fP handle, const char * objectName, vdsObjectType objectType)"
.PP
.SS "int vdsDestroyObject (\fBVDS_HANDLE\fP handle, const char * objectName)"
.PP
.SS "void vdsExit (\fBVDS_HANDLE\fP processHandle)"
.PP
This function terminates all access to the VDS. 
.PP
This function will also close all sessions and terminate all accesses to the different objects.
.PP
This function takes a single argument, the handle to the process object and always end successfully.
.SS "void vdsExitSession (\fBVDS_HANDLE\fP handle)"
.PP
.SS "int vdsFolderClose (\fBVDS_HANDLE\fP objectHandle)"
.PP
.SS "int vdsFolderOpen (\fBVDS_HANDLE\fP sessionHandle, const char * folderName, \fBVDS_HANDLE\fP * objectHandle)"
.PP
.SS "int vdsInit (const char * wdAddress, int protectionNeeded, \fBVDS_HANDLE\fP * processHandle)"
.PP
This function initializes access to a VDS. 
.PP
It takes 2 input arguments, the address of the watchdog and an integer (used as a boolean, 0 for false, 1 for true) to indicate if sessions and other objects (Queues, etc) are shared amongst threads (in the current process) and must be protected. Recommendation: always set protectionNeeded to 0 (false) unless you cannot do it otherwise. In other words it is recommended to use one session handle for each thread. Also if the same queue needs to be accessed by two threads it is more efficient to have two different handles instead of sharing a single one.
.PP
[Additional note: API objects (or C handles) are just proxies for the real objects sitting in shared memory. Proper synchronization is already done in shared memory and it is best to avoid to synchronize these proxy objects.]
.PP
Upon successful completion, the process handle is set. Otherwise the error code is returned.
.SS "int vdsInitSession (int explicitTransaction, \fBVDS_HANDLE\fP * sessionHandle)"
.PP
This function initializes a session. 
.PP
It takes one input argument, an integer (used as a boolean, 0 for false, 1 for true) to indicate if transactions are implicit or explicit for the current session (see below).
.PP
Upon successful completion, the session handle is set. Otherwise the error code is returned.
.PP
Two types of transaction management, implicit and explicit.
.PP
.IP "\(bu" 2
Implicit transactions, as the name indicates, hides all transactions from the application. The underlying framework will periodically save the current work at predetermined 'check points'. The method Commit can be called to save the current work but Rollback is unavailable. Upon normal termination, the current work is automatically saved.
.PP
.PP
.IP "\(bu" 2
Explicit transactions are ideal for real-time processing. Contrary to some other transaction management software, every call made in such a session is part of the transaction (in other words a new transaction is started immediately after either Commit or RollBack was called). Upon normal termination, the current transaction is rolled back.
.PP

.SS "int vdsQueueClose (\fBVDS_HANDLE\fP objectHandle)"
.PP
.SS "int vdsQueueGetItem (\fBVDS_HANDLE\fP objectHandle, vdsIteratorType flag, void * pItem, size_t length)"
.PP
.SS "int vdsQueueInsertItem (\fBVDS_HANDLE\fP objectHandle, const void * pItem, size_t length)"
.PP
.SS "int vdsQueueOpen (\fBVDS_HANDLE\fP sessionHandle, const char * queueName, \fBVDS_HANDLE\fP * objectHandle)"
.PP
.SS "int vdsQueueRemoveItem (\fBVDS_HANDLE\fP objectHandle, void * pItem, size_t length)"
.PP
.SS "int vdsQueueStatus (\fBVDS_HANDLE\fP objectHandle, size_t * pNumValidItems, size_t * pNumTotalItems)"
.PP
.SS "int vdsRollback (\fBVDS_HANDLE\fP handle)"
.PP
.SH "Author"
.PP 
Generated automatically by Doxygen for vdsf C API from the source code.
