.TH "vds_c.h" 3 "3 Oct 2007" "Version 0.1" "vdsf C API" \" -*- nroff -*-
.ad l
.nh
.SH NAME
vds_c.h \- 
.SH SYNOPSIS
.br
.PP
\fC#include 'vdsf/vdsErrors.h'\fP
.br
\fC#include 'vdsf/vdsCommon.h'\fP
.br

.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef void * \fBVDS_HANDLE\fP"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "VDSF_EXPORT int \fBvdsInit\fP (const char *wdAddress, int protectionNeeded, \fBVDS_HANDLE\fP *processHandle)"
.br
.RI "\fIThis function initializes access to a VDS. \fP"
.ti -1c
.RI "VDSF_EXPORT void \fBvdsExit\fP (\fBVDS_HANDLE\fP processHandle)"
.br
.RI "\fIThis function terminates all access to the VDS. \fP"
.ti -1c
.RI "VDSF_EXPORT int \fBvdsInitSession\fP (\fBVDS_HANDLE\fP *sessionHandle)"
.br
.RI "\fIThis function initializes a session. \fP"
.ti -1c
.RI "VDSF_EXPORT int \fBvdsExitSession\fP (\fBVDS_HANDLE\fP handle)"
.br
.ti -1c
.RI "VDSF_EXPORT int \fBvdsCreateObject\fP (\fBVDS_HANDLE\fP handle, const char *objectName, vdsObjectType objectType)"
.br
.ti -1c
.RI "VDSF_EXPORT int \fBvdsDestroyObject\fP (\fBVDS_HANDLE\fP handle, const char *objectName)"
.br
.ti -1c
.RI "VDSF_EXPORT int \fBvdsCommit\fP (\fBVDS_HANDLE\fP handle)"
.br
.ti -1c
.RI "VDSF_EXPORT int \fBvdsRollback\fP (\fBVDS_HANDLE\fP handle)"
.br
.ti -1c
.RI "VDSF_EXPORT int \fBvdsFolderOpen\fP (\fBVDS_HANDLE\fP sessionHandle, const char *folderName, \fBVDS_HANDLE\fP *objectHandle)"
.br
.ti -1c
.RI "VDSF_EXPORT int \fBvdsFolderClose\fP (\fBVDS_HANDLE\fP objectHandle)"
.br
.ti -1c
.RI "VDSF_EXPORT int \fBvdsQueueOpen\fP (\fBVDS_HANDLE\fP sessionHandle, const char *queueName, \fBVDS_HANDLE\fP *objectHandle)"
.br
.ti -1c
.RI "VDSF_EXPORT int \fBvdsQueueClose\fP (\fBVDS_HANDLE\fP objectHandle)"
.br
.ti -1c
.RI "VDSF_EXPORT int \fBvdsQueueInsertItem\fP (\fBVDS_HANDLE\fP objectHandle, const void *pItem, size_t length)"
.br
.ti -1c
.RI "VDSF_EXPORT int \fBvdsQueueRemoveItem\fP (\fBVDS_HANDLE\fP objectHandle, void *pItem, size_t length)"
.br
.ti -1c
.RI "VDSF_EXPORT int \fBvdsQueueGetItem\fP (\fBVDS_HANDLE\fP objectHandle, vdsIteratorType flag, void *pItem, size_t length)"
.br
.ti -1c
.RI "VDSF_EXPORT int \fBvdsQueueStatus\fP (\fBVDS_HANDLE\fP objectHandle, size_t *pNumValidItems, size_t *pNumTotalItems)"
.br
.in -1c
.SH "Typedef Documentation"
.PP 
.SS "typedef void* \fBVDS_HANDLE\fP"
.PP
Definition at line 28 of file vds_c.h.
.SH "Function Documentation"
.PP 
.SS "VDSF_EXPORT int vdsCommit (\fBVDS_HANDLE\fP handle)"
.PP
.SS "VDSF_EXPORT int vdsCreateObject (\fBVDS_HANDLE\fP handle, const char * objectName, vdsObjectType objectType)"
.PP
.SS "VDSF_EXPORT int vdsDestroyObject (\fBVDS_HANDLE\fP handle, const char * objectName)"
.PP
.SS "VDSF_EXPORT void vdsExit (\fBVDS_HANDLE\fP processHandle)"
.PP
This function terminates all access to the VDS. 
.PP
This function will also close all sessions and terminate all accesses to the different objects.
.PP
This function takes a single argument, the handle to the process object and always end successfully. 
.SS "VDSF_EXPORT int vdsExitSession (\fBVDS_HANDLE\fP handle)"
.PP
.SS "VDSF_EXPORT int vdsFolderClose (\fBVDS_HANDLE\fP objectHandle)"
.PP
.SS "VDSF_EXPORT int vdsFolderOpen (\fBVDS_HANDLE\fP sessionHandle, const char * folderName, \fBVDS_HANDLE\fP * objectHandle)"
.PP
.SS "VDSF_EXPORT int vdsInit (const char * wdAddress, int protectionNeeded, \fBVDS_HANDLE\fP * processHandle)"
.PP
This function initializes access to a VDS. 
.PP
It takes 2 input arguments, the address of the watchdog and an integer (used as a boolean, 0 for false, 1 for true) to indicate if sessions and other objects (Queues, etc) are shared amongst threads (in the current process) and must be protected. Recommendation: always set protectionNeeded to 0 (false) unless you cannot do it otherwise. In other words it is recommended to use one session handle for each thread. Also if the same queue needs to be accessed by two threads it is more efficient to have two different handles instead of sharing a single one.
.PP
[Additional note: API objects (or C handles) are just proxies for the real objects sitting in shared memory. Proper synchronization is already done in shared memory and it is best to avoid to synchronize these proxy objects.]
.PP
Upon successful completion, the process handle is set. Otherwise the error code is returned. 
.SS "VDSF_EXPORT int vdsInitSession (\fBVDS_HANDLE\fP * sessionHandle)"
.PP
This function initializes a session. 
.PP
It takes one output argument, the session handle.
.PP
Upon successful completion, the session handle is set and the function returns zero. Otherwise the error code is returned and the handle is set to NULL.
.PP
This function will also initiate a new transaction:
.PP
Contrary to some other transaction management software, almost every call made is part of a transaction. Even viewing data (for example deleting the data by another session will be delayed until the current session terminates its access).
.PP
Upon normal termination, the current transaction is rolled back. You MUST explicitly call vdseCommit to save your changes. 
.SS "VDSF_EXPORT int vdsQueueClose (\fBVDS_HANDLE\fP objectHandle)"
.PP
.SS "VDSF_EXPORT int vdsQueueGetItem (\fBVDS_HANDLE\fP objectHandle, vdsIteratorType flag, void * pItem, size_t length)"
.PP
.SS "VDSF_EXPORT int vdsQueueInsertItem (\fBVDS_HANDLE\fP objectHandle, const void * pItem, size_t length)"
.PP
.SS "VDSF_EXPORT int vdsQueueOpen (\fBVDS_HANDLE\fP sessionHandle, const char * queueName, \fBVDS_HANDLE\fP * objectHandle)"
.PP
.SS "VDSF_EXPORT int vdsQueueRemoveItem (\fBVDS_HANDLE\fP objectHandle, void * pItem, size_t length)"
.PP
.SS "VDSF_EXPORT int vdsQueueStatus (\fBVDS_HANDLE\fP objectHandle, size_t * pNumValidItems, size_t * pNumTotalItems)"
.PP
.SS "VDSF_EXPORT int vdsRollback (\fBVDS_HANDLE\fP handle)"
.PP
.SH "Author"
.PP 
Generated automatically by Doxygen for vdsf C API from the source code.
