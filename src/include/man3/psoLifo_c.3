.TH "API functions for Photon LIFO queues." 3 "27 Mar 2009" "Version 0.5.0" "Photon Software" \" -*- nroff -*-
.ad l
.nh
.SH NAME
API functions for Photon LIFO queues. \- 
.SH "Detailed Description"
.PP 
A reminder: LIFO, Last In First Out. 
.PP
Data items are placed at the end of the queue and retrieved from the end of the queue. 
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoLifoClose\fP (\fBPSO_HANDLE\fP objectHandle)"
.br
.RI "\fIClose a LIFO queue. \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoLifoDefinition\fP (\fBPSO_HANDLE\fP objectHandle, \fBpsoObjectDefinition\fP *definition, unsigned char *fields, \fBpsoUint32\fP fieldsLength)"
.br
.RI "\fIRetrieve the data definition of the queue. \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoLifoDefLength\fP (\fBPSO_HANDLE\fP objectHandle, \fBpsoUint32\fP *fieldsLength)"
.br
.RI "\fIRetrieve the length of the fields definition of the queue. \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoLifoGetFirst\fP (\fBPSO_HANDLE\fP objectHandle, void *buffer, \fBpsoUint32\fP bufferLength, \fBpsoUint32\fP *returnedLength)"
.br
.RI "\fIIterate through the queue - no data items are removed from the queue by this function. \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoLifoGetNext\fP (\fBPSO_HANDLE\fP objectHandle, void *buffer, \fBpsoUint32\fP bufferLength, \fBpsoUint32\fP *returnedLength)"
.br
.RI "\fIIterate through the queue - no data items are removed from the queue by this function. \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoLifoOpen\fP (\fBPSO_HANDLE\fP sessionHandle, const char *queueName, \fBpsoUint32\fP nameLengthInBytes, \fBPSO_HANDLE\fP *objectHandle)"
.br
.RI "\fIOpen an existing LIFO queue (see \fBpsoCreateObject\fP to create a new queue). \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoLifoPop\fP (\fBPSO_HANDLE\fP objectHandle, void *buffer, \fBpsoUint32\fP bufferLength, \fBpsoUint32\fP *returnedLength)"
.br
.RI "\fIRemove the first item from the beginning of a LIFO queue and return it to the caller. \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoLifoPush\fP (\fBPSO_HANDLE\fP objectHandle, const void *pItem, \fBpsoUint32\fP length)"
.br
.RI "\fIInsert a data element at the end of the LIFO queue. \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoLifoStatus\fP (\fBPSO_HANDLE\fP objectHandle, \fBpsoObjStatus\fP *pStatus)"
.br
.RI "\fIReturn the status of the queue. \fP"
.in -1c
.SH "Function Documentation"
.PP 
.SS "PHOTON_EXPORT int psoLifoClose (\fBPSO_HANDLE\fP objectHandle)"
.PP
Close a LIFO queue. 
.PP
This function terminates the current access to the queue in shared memory (the queue itself is untouched).
.PP
\fBWarning:\fP
.RS 4
Closing an object does not automatically commit or rollback data items that were inserted or removed. You still must use either \fBpsoCommit\fP or \fBpsoRollback\fP to end the current unit of work.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIobjectHandle\fP The handle to the queue (see \fBpsoLifoOpen\fP). 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoLifoDefinition (\fBPSO_HANDLE\fP objectHandle, \fBpsoObjectDefinition\fP * definition, unsigned char * fields, \fBpsoUint32\fP fieldsLength)"
.PP
Retrieve the data definition of the queue. 
.PP
You can call the function \fBpsoLifoDefLength\fP to retrieve the length of the field definitions. This allows you to allocate the proper size for \fIfields\fP.
.PP
\fBParameters:\fP
.RS 4
\fIobjectHandle\fP The handle to the queue (see \fBpsoLifoOpen\fP). 
.br
\fIdefinition\fP The definition of the object. 
.br
\fIfields\fP An opaque definition of the data fields of the object. It can be set to NULL if you do not want to retrieve the definition. 
.br
\fIfieldsLength\fP The length, in bytes, of the buffer \fIfields\fP. It should be set to zero if \fIfields\fP is NULL.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoLifoDefLength (\fBPSO_HANDLE\fP objectHandle, \fBpsoUint32\fP * fieldsLength)"
.PP
Retrieve the length of the fields definition of the queue. 
.PP
This function is a helper function for \fBpsoLifoDefinition\fP. It allows you to allocate the proper size for \fIfields\fP.
.PP
\fBParameters:\fP
.RS 4
\fIobjectHandle\fP The handle to the queue (see \fBpsoLifoOpen\fP). 
.br
\fIfieldsLength\fP The length in bytes of the fields buffer.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoLifoGetFirst (\fBPSO_HANDLE\fP objectHandle, void * buffer, \fBpsoUint32\fP bufferLength, \fBpsoUint32\fP * returnedLength)"
.PP
Iterate through the queue - no data items are removed from the queue by this function. 
.PP
Data items which were added by another session and are not yet committed will not be seen by the iterator. Likewise, destroyed data items (even if not yet committed) are invisible.
.PP
\fBParameters:\fP
.RS 4
\fIobjectHandle\fP The handle to the queue (see \fBpsoLifoOpen\fP). 
.br
\fIbuffer\fP The buffer provided by the user to hold the content of the first element. Memory allocation for this buffer is the responsability of the caller. 
.br
\fIbufferLength\fP The length of \fIbuffer\fP (in bytes). 
.br
\fIreturnedLength\fP The actual number of bytes in the data item.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoLifoGetNext (\fBPSO_HANDLE\fP objectHandle, void * buffer, \fBpsoUint32\fP bufferLength, \fBpsoUint32\fP * returnedLength)"
.PP
Iterate through the queue - no data items are removed from the queue by this function. 
.PP
Data items which were added by another session and are not yet committed will not be seen by the iterator. Likewise, destroyed data items (even if not yet committed) are invisible.
.PP
Evidently, you must call \fBpsoLifoGetFirst\fP to initialize the iterator. Not so evident - calling \fBpsoLifoPop\fP will reset the iteration to the last element (they use the same internal storage). If this cause a problem, please let us know.
.PP
\fBParameters:\fP
.RS 4
\fIobjectHandle\fP The handle to the queue (see \fBpsoLifoOpen\fP). 
.br
\fIbuffer\fP The buffer provided by the user to hold the content of the next element. Memory allocation for this buffer is the responsability of the caller. 
.br
\fIbufferLength\fP The length of \fIbuffer\fP (in bytes). 
.br
\fIreturnedLength\fP The actual number of bytes in the data item.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoLifoOpen (\fBPSO_HANDLE\fP sessionHandle, const char * queueName, \fBpsoUint32\fP nameLengthInBytes, \fBPSO_HANDLE\fP * objectHandle)"
.PP
Open an existing LIFO queue (see \fBpsoCreateObject\fP to create a new queue). 
.PP
\fBParameters:\fP
.RS 4
\fIsessionHandle\fP The handle to the current session. 
.br
\fIqueueName\fP The fully qualified name of the queue. 
.br
\fInameLengthInBytes\fP The length of \fIqueueName\fP (in bytes) not counting the null terminator (null-terminators are not used by the Photon engine). 
.br
\fIobjectHandle\fP The handle to the queue, allowing us access to the queue in shared memory. On error, this handle will be set to zero (NULL) unless the objectHandle pointer itself is NULL.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoLifoPop (\fBPSO_HANDLE\fP objectHandle, void * buffer, \fBpsoUint32\fP bufferLength, \fBpsoUint32\fP * returnedLength)"
.PP
Remove the first item from the beginning of a LIFO queue and return it to the caller. 
.PP
Data items which were added by another session and are not yet committed will not be seen by this function. Likewise, destroyed data items (even if not yet committed) are invisible.
.PP
The removals only become permanent after a call to \fBpsoCommit\fP.
.PP
\fBParameters:\fP
.RS 4
\fIobjectHandle\fP The handle to the queue (see \fBpsoLifoOpen\fP). 
.br
\fIbuffer\fP The buffer provided by the user to hold the content of the data item. Memory allocation for this buffer is the responsability of the caller. 
.br
\fIbufferLength\fP The length of \fIbuffer\fP (in bytes). 
.br
\fIreturnedLength\fP The actual number of bytes in the data item.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoLifoPush (\fBPSO_HANDLE\fP objectHandle, const void * pItem, \fBpsoUint32\fP length)"
.PP
Insert a data element at the end of the LIFO queue. 
.PP
The additions only become permanent after a call to \fBpsoCommit\fP.
.PP
\fBParameters:\fP
.RS 4
\fIobjectHandle\fP The handle to the queue (see \fBpsoLifoOpen\fP). 
.br
\fIpItem\fP The data item to be inserted. 
.br
\fIlength\fP The length of \fIpItem\fP (in bytes).
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoLifoStatus (\fBPSO_HANDLE\fP objectHandle, \fBpsoObjStatus\fP * pStatus)"
.PP
Return the status of the queue. 
.PP
\fBParameters:\fP
.RS 4
\fIobjectHandle\fP The handle to the queue (see \fBpsoLifoOpen\fP). 
.br
\fIpStatus\fP A pointer to the status structure.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

