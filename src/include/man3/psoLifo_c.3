.TH "API functions for Photon LIFO queues." 3 "10 Nov 2008" "Version 0.4.0" "Photon Software" \" -*- nroff -*-
.ad l
.nh
.SH NAME
API functions for Photon LIFO queues. \- 
.SH "Detailed Description"
.PP 
A reminder: LIFO, Last In First Out. 
.PP
Data items are placed at the end of the queue and retrieved from the end of the queue. 
.PP
.SS "Functions"

.in +1c
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoLifoClose\fP (\fBPSO_HANDLE\fP objectHandle)"
.br
.RI "\fIClose a LIFO queue. \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoLifoDefinition\fP (\fBPSO_HANDLE\fP objectHandle, \fBpsoObjectDefinition\fP **definition)"
.br
.RI "\fIRetrieve the data definition of the queue. \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoLifoGetFirst\fP (\fBPSO_HANDLE\fP objectHandle, void *buffer, size_t bufferLength, size_t *returnedLength)"
.br
.RI "\fIIterate through the queue - no data items are removed from the queue by this function. \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoLifoGetNext\fP (\fBPSO_HANDLE\fP objectHandle, void *buffer, size_t bufferLength, size_t *returnedLength)"
.br
.RI "\fIIterate through the queue - no data items are removed from the queue by this function. \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoLifoOpen\fP (\fBPSO_HANDLE\fP sessionHandle, const char *queueName, size_t nameLengthInBytes, \fBPSO_HANDLE\fP *objectHandle)"
.br
.RI "\fIOpen an existing LIFO queue (see \fBpsoCreateObject\fP to create a new queue). \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoLifoPop\fP (\fBPSO_HANDLE\fP objectHandle, void *buffer, size_t bufferLength, size_t *returnedLength)"
.br
.RI "\fIRemove the first item from the beginning of a LIFO queue and return it to the caller. \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoLifoPush\fP (\fBPSO_HANDLE\fP objectHandle, const void *pItem, size_t length)"
.br
.RI "\fIInsert a data element at the end of the LIFO queue. \fP"
.ti -1c
.RI "PHOTON_EXPORT int \fBpsoLifoStatus\fP (\fBPSO_HANDLE\fP objectHandle, \fBpsoObjStatus\fP *pStatus)"
.br
.RI "\fIReturn the status of the queue. \fP"
.in -1c
.SH "Function Documentation"
.PP 
.SS "PHOTON_EXPORT int psoLifoClose (\fBPSO_HANDLE\fP objectHandle)"
.PP
Close a LIFO queue. 
.PP
This function terminates the current access to the queue in shared memory (the queue itself is untouched).
.PP
\fBWarning:\fP
.RS 4
Closing an object does not automatically commit or rollback data items that were inserted or removed. You still must use either \fBpsoCommit\fP or \fBpsoRollback\fP to end the current unit of work.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIobjectHandle\fP The handle to the queue (see \fBpsoLifoOpen\fP). 
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoLifoDefinition (\fBPSO_HANDLE\fP objectHandle, \fBpsoObjectDefinition\fP ** definition)"
.PP
Retrieve the data definition of the queue. 
.PP
\fBWarning:\fP
.RS 4
This function allocates a buffer to hold the definition (using malloc()). You must free it (with free()) when you no longer need the definition.
.RE
.PP
\fBParameters:\fP
.RS 4
\fIobjectHandle\fP The handle to the queue (see \fBpsoLifoOpen\fP). 
.br
\fIdefinition\fP The buffer allocated by the API to hold the content of the object definition. Freeing the memory (with free()) is the responsability of the caller.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoLifoGetFirst (\fBPSO_HANDLE\fP objectHandle, void * buffer, size_t bufferLength, size_t * returnedLength)"
.PP
Iterate through the queue - no data items are removed from the queue by this function. 
.PP
Data items which were added by another session and are not yet committed will not be seen by the iterator. Likewise, destroyed data items (even if not yet committed) are invisible.
.PP
\fBParameters:\fP
.RS 4
\fIobjectHandle\fP The handle to the queue (see \fBpsoLifoOpen\fP). 
.br
\fIbuffer\fP The buffer provided by the user to hold the content of the first element. Memory allocation for this buffer is the responsability of the caller. 
.br
\fIbufferLength\fP The length of \fIbuffer\fP (in bytes). 
.br
\fIreturnedLength\fP The actual number of bytes in the data item.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoLifoGetNext (\fBPSO_HANDLE\fP objectHandle, void * buffer, size_t bufferLength, size_t * returnedLength)"
.PP
Iterate through the queue - no data items are removed from the queue by this function. 
.PP
Data items which were added by another session and are not yet committed will not be seen by the iterator. Likewise, destroyed data items (even if not yet committed) are invisible.
.PP
Evidently, you must call \fBpsoLifoGetFirst\fP to initialize the iterator. Not so evident - calling \fBpsoLifoPop\fP will reset the iteration to the last element (they use the same internal storage). If this cause a problem, please let us know.
.PP
\fBParameters:\fP
.RS 4
\fIobjectHandle\fP The handle to the queue (see \fBpsoLifoOpen\fP). 
.br
\fIbuffer\fP The buffer provided by the user to hold the content of the next element. Memory allocation for this buffer is the responsability of the caller. 
.br
\fIbufferLength\fP The length of \fIbuffer\fP (in bytes). 
.br
\fIreturnedLength\fP The actual number of bytes in the data item.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoLifoOpen (\fBPSO_HANDLE\fP sessionHandle, const char * queueName, size_t nameLengthInBytes, \fBPSO_HANDLE\fP * objectHandle)"
.PP
Open an existing LIFO queue (see \fBpsoCreateObject\fP to create a new queue). 
.PP
\fBParameters:\fP
.RS 4
\fIsessionHandle\fP The handle to the current session. 
.br
\fIqueueName\fP The fully qualified name of the queue. 
.br
\fInameLengthInBytes\fP The length of \fIqueueName\fP (in bytes) not counting the null terminator (null-terminators are not used by the Photon engine). 
.br
\fIobjectHandle\fP The handle to the queue, allowing us access to the queue in shared memory. On error, this handle will be set to zero (NULL) unless the objectHandle pointer itself is NULL.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoLifoPop (\fBPSO_HANDLE\fP objectHandle, void * buffer, size_t bufferLength, size_t * returnedLength)"
.PP
Remove the first item from the beginning of a LIFO queue and return it to the caller. 
.PP
Data items which were added by another session and are not yet committed will not be seen by this function. Likewise, destroyed data items (even if not yet committed) are invisible.
.PP
The removals only become permanent after a call to \fBpsoCommit\fP.
.PP
\fBParameters:\fP
.RS 4
\fIobjectHandle\fP The handle to the queue (see \fBpsoLifoOpen\fP). 
.br
\fIbuffer\fP The buffer provided by the user to hold the content of the data item. Memory allocation for this buffer is the responsability of the caller. 
.br
\fIbufferLength\fP The length of \fIbuffer\fP (in bytes). 
.br
\fIreturnedLength\fP The actual number of bytes in the data item.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoLifoPush (\fBPSO_HANDLE\fP objectHandle, const void * pItem, size_t length)"
.PP
Insert a data element at the end of the LIFO queue. 
.PP
The additions only become permanent after a call to \fBpsoCommit\fP.
.PP
\fBParameters:\fP
.RS 4
\fIobjectHandle\fP The handle to the queue (see \fBpsoLifoOpen\fP). 
.br
\fIpItem\fP The data item to be inserted. 
.br
\fIlength\fP The length of \fIpItem\fP (in bytes).
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

.SS "PHOTON_EXPORT int psoLifoStatus (\fBPSO_HANDLE\fP objectHandle, \fBpsoObjStatus\fP * pStatus)"
.PP
Return the status of the queue. 
.PP
\fBParameters:\fP
.RS 4
\fIobjectHandle\fP The handle to the queue (see \fBpsoLifoOpen\fP). 
.br
\fIpStatus\fP A pointer to the status structure.
.RE
.PP
\fBReturns:\fP
.RS 4
0 on success or a \fBpsoErrors\fP on error. 
.RE
.PP

